# PrÃ©parer sa base de donnÃ©es postgresql

Si on remet un peu les choses dans leur contexte, vous savez aujourd'hui interagir avec une base de donnÃ©es grÃ¢ce au langage SQL et vous avez une bonne idÃ©e de la faÃ§on dont ces bases de donnÃ©es sont conÃ§ues. C'est trÃ¨s cool, mais je peux anticiper votre prochaine question : comment crÃ©er la base de donnÃ©es de nos rÃªves maintenant que nous avons fait une conception aux petits oignons ?

C'est exactement ce que nous allons voir aujourd'hui. Voici quelques questions que nous allons aborder :

   - Comment communiquer avec PostgreSQL pour gÃ©rer nos bases de donnÃ©es ? **utilisation de psql**
   - Comment crÃ©er une nouvelle base de donnÃ©es ? **utilisation de CREATE DATABASE**
   - Comment crÃ©er un utilisateur sur le serveur PostgreSQL ? **utilisation de CREATE USER**
   - Comment crÃ©er une table ? Peut-on automatiser la crÃ©ation avec des scripts SQL ? **utilisation de CREATE TABLE**
   - Comment remplir initialement nos tables ? **le seeding**
   - Comment faire une sauvegarde de l'Ã©tat d'une base de donnÃ©es ? **le dump**

## La ligne de commande PSQL

Qu'elle soit distante ou locale, pour accÃ©der Ã  une base de donnÃ©es il faut d'abord s'y connecter. On va utiliser un client en ligne de commande (CLI => command line interface) pour nous y connecter. Ce client s'appelle **psql** et est spÃ©cifique aux bases de donnÃ©es PostgreSQL.

Par dÃ©faut, si vous lancez la commande psql sans aucun argument, elle essaiera de se connecter au serveur PostgreSQL installÃ© sur votre machine (localhost) avec l'utilisateur de votre systÃ¨me d'exploitation.

MÃªme si notre objectif est bien de nous connecter Ã  notre base de donnÃ©es locale, l'utilisation de notre nom d'utilisateur Windows, Linux ou macOS n'est pas forcÃ©ment ce que nous voudrons Ã  l'avenir.

Fort heureusement, comme toutes bonnes commandes de terminal, **psql** vous offre tout un tas d'arguments qui vont vous permettre de spÃ©cifier des Ã©lÃ©ments de configuration ou de lui indiquer des actions Ã  rÃ©aliser. Voici une liste non exhaustive d'arguments que vous pouvez renseigner Ã  psql :

```
-h [hostname] // spÃ©cifie le nom d'hÃ´te du serveur PostgreSQL sur lequel vous voulez exÃ©cuter psql - par dÃ©faut, psql utilisera localhost 
-U [username] // spÃ©cifie le nom d'utilisateur PostgreSQL que vous voulez utiliser pour vous connecter - par dÃ©faut le nom d'utilisateur de l'OS
-d [databasename] // spÃ©cifie le nom de la base de donnÃ©es sur laquelle vous voulez travailler - par dÃ©faut, psql utilisera le nom d'utilisateur
```

Il existe toutefois un `superUser` pour gÃ©rer votre base de donnÃ©es, qu'elle soit locale ou non, il s'agit d'un utilisateur crÃ©Ã© sur votre systÃ¨me d'exploitation au moment de l'installation de PostgreSQL. Cet utilisateur s'appelle `postgres` et il a tous les droits sur votre RDBMS.

Sous Windows, pour vous y connecter vous utiliserez la commande :

```bash
psql -U postgres
```
puis vous entrerez le mot de passe de votre session utilisateur courante.

C'est cet utilisateur qui nous servira dans un premier temps pour crÃ©er les bases de donnÃ©es et les utilisateurs de notre RDBMS

Une fois connectÃ©, vous aurez accÃ¨s Ã  l'Ã©criture de requÃªte SQL standard, ainsi qu'a certaine commandes de **psql** 

```
\l = liste les base de donnÃ©es
\du = liste les utilisateurs
\q = quitte psql
\dt = liste les tables de la base de donnÃ©es sur laquelle on est connectÃ©e
\d student = dÃ©crit la table student
...
```

### CrÃ©er une base de donnÃ©e et d'un user avec psql

Une fois connectÃ© via **psql** avec l'utilisateur `postgres`, on peut crÃ©er un utilisateur au sein mÃªme de notre RDBMS.

Pourquoi ? Eh bien, en fait, c'est pour des questions de sÃ©curitÃ©. En effet, vous retrouverez souvent cette gestion d'utilisateurs dans les environnements en production et pas seulement sur les bases de donnÃ©es. En production, il est de coutume (peu importe le service, web, base de donnÃ©es, ftp, mail, ...) de crÃ©er des utilisateurs spÃ©cifiques pour chaque application mise en production dans un mÃªme environnement.

Je m'explique, admettons que vous Ãªtes l'administrateur d'un serveur qui gÃ¨re la boutique en ligne d'Oclock, O'Shop, ainsi que notre systÃ¨me d'envoi et de rÃ©ception de mails. En bon administrateur systÃ¨me, vous allez trÃ¨s certainement crÃ©er un utilisateur qui va gÃ©rer l'exÃ©cution du site web de la boutique, ainsi qu'un autre qui gÃ©rera la BDD et encore un pour gÃ©rer le systÃ¨me de mail. De mÃªme au sein du RDBMS, vous allez donc crÃ©er un utilisateur qui va gÃ©rer l'application O'Shop et un autre qui s'occupera de gÃ©rer les donnÃ©es du systÃ¨me de mail. Bref, l'idÃ©e est de toujours sÃ©parer les droits d'une application Ã  l'autre.

On va donc dans notre DBMS crÃ©er un utilisateur spÃ©cifique pour chaque base de donnÃ©es que l'on voudra administrer.

 > Ok, c'est sympa mais concrÃ¨tement, comment on fait ?

Eh bien, une fois connectÃ© Ã  votre Postgres avec le superuser `postgres`, on va pouvoir crÃ©er un nouvel utilisateur. Voici la syntaxe :

```sql
CREATE USER name [ [ WITH ] option [ ... ] ]
```

Ã‰videmment, il s'agit de la syntaxe de [la documentation](https://www.postgresql.org/docs/current/sql-createuser.html).

On va essayer de prÃ©ciser un peu les choses :

```sql
CREATE USER cinema WITH PASSWORD 'mon_super_mot_de_passe_ultra_secure_parce_que_faut_bien_sÃ©curier_l_acces_aux_donnees';
```
Dans ce cas prÃ©cis, on demande Ã  Postgres de crÃ©er un utilisateur appelÃ© `cinema` qui aura la possibilitÃ© de se logger avec le mot de passe mon_super_mot_de_passe_ultra_secure_parce_que_faut_bien_securier_l_acces_aux_donnees.

VoilÃ , votre utilisateur est crÃ©Ã©, on va maintenant le lier Ã  une nouvelle base de donnÃ©es.

Par ailleurs si vous voulez modifier un Ã©lement dÃ©jÃ  crÃ©Ã©, on peut utiliser la commande `ALTER` soit

```sql
ALTER USER cinema WITH PASSWORD 'mon_nouveau_mot_de_passe';
```

On peut noter qu'on trouvera aussi la commande `DROP` pour supprimer un Ã©lement.

Comme pour la crÃ©ation de l'utilisateur, la syntaxe pour crÃ©er une base de donnÃ©es est dÃ©crite dans [la documentation](https://www.postgresql.org/docs/current/sql-createdatabase.html) et ressemble Ã  Ã§a :

```sql
CREATE DATABASE name [ WITH ] [ OWNER [=] user_name ]
```

On va demander la crÃ©ation de la base et dans le mÃªme temps, on va dÃ©finir notre utilisateur fraÃ®chement crÃ©Ã© comme Ã©tant le propriÃ©taire de cette derniÃ¨re.

```sql
CREATE DATABASE cinema WITH OWNER cinema;
```

On va maintenant pouvoir quitter psql avec un \q et se connecter avec notre nouvel utilisateur :

```bash
psql -d cinema -U cinema -h localhost

# mais comme psql par dÃ©faut se connecte Ã  localhost
psql -d cinema -U cinema

# mais comme psql par dÃ©faut se connecte Ã  la bdd qui porte le mÃªme nom que l'utilisateur 
psql -U cinema
```

Et voilÃ , on a un utilisateur qui a les droits uniquement sur cette base de donnÃ©es cinema.

### CrÃ©er une table en ligne de commande

Parfait, on vient de crÃ©er notre premiÃ¨re base en locale et un utilisateur pour l'administrer. On va du coup maintenant pouvoir passer aux choses sÃ©rieuses et crÃ©er nos propres tables. Bien entendu, Postrgres nous founi la syntaxe dans [la documentation](https://www.postgresql.org/docs/current/sql-createtable.html).

Bon, cette fois ci, on va se passer d'afficher la syntaxe ici parce que la doc pourrait Ãªtre considÃ©rÃ©e comme ... complÃ¨te ğŸ˜•

Par contre on peut se faire un premier exemple. Voici un petit MPD pour une table `movie` :

```sql
"movie" (
  "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY, -- Un identifiant unique gÃ©nÃ©rÃ© par le RDBMS
  "title" TEXT NOT NULL, -- il est obligatoire
  "year" INTEGER NOT NULL, -- obligatoire aussi
  "excerpt" TEXT,
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(), -- on veut savoir quand un film a Ã©tÃ© ajoutÃ© dans la base et on dÃ©fini la valeur par dÃ©faut comme Ã©tant maintenant       (c'est a dire au moment ou le film sera ajoutÃ©)
  "updated_at TIMESTAMPTZ
)
```

Si on fait la traduction en SQL pour Postgres on aurait simplement Ã  ajouter l'instruction `CRATE TABLE` devant :

```sql
CREATE TABLE "movie" (
  "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  
  "title" TEXT NOT NULL, 
  "year" INTEGER NOT NULL, 
  "excerpt" TEXT,
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  "updated_at" TIMESTAMPTZ
);
```
Au final, la requÃªte SQL qui permet de crÃ©er la table est trÃ¨s proche du MPD.

```
CREATE TABLE table_name (
   champ1,
   champ2,
   champ3
);
```

Et voila, on a une base de donnÃ©e la possibilitÃ© d'y crÃ©er des tables.

Bon par contre c'est un peu fastidieux, et je suis pas sÃ»r que si je demande Ã  un adminsys d'Ã©crire lui aussi les requÃªtes sur le serveur de production il soit super emballÃ©. Du coup, quel genre d'outils on aime faire pour que les choses aillent plus vite ? Un script !

## CrÃ©ation d'un script de deploiement de BDD

L'idÃ©e, Ã§a va Ãªtre de crÃ©er un fichier avec l'extension `.sql` et  qui va contenir une suite d'instructions SQL qui vont permettre de reconstruire toute la structure d'une base de donnÃ©es. Ce script va contenir principalement des instructions CREATE TABLE qui vont permettre Ã  n'importe qui d'avoir exactement les mÃªmes tables et les mÃªmes champs dans une autre base de donnÃ©es, voire mÃªme sur un autre serveur.

### Mise en place de la transaction

> Waouh ! Ok, on va pirater Wall Street ???

Non, pas du tout. En revanche, on va Ã©changer avec la base de donnÃ©es et on va lui envoyer beaucoup d'informations en mÃªme temps. Du coup, ce serait plutÃ´t intÃ©ressant que la base de donnÃ©es simule ce qui va se passer avec notre script avant de l'exÃ©cuter rÃ©ellement. Comme Ã§a, si il y a des erreurs dans le script, elle pourra tout arrÃªter et nous avertir que le script est faux. Eh bien, c'est justement le principe de la transaction. En fait, on va simplement indiquer Ã  notre RDBMS Ã  quel moment notre script dÃ©marre et oÃ¹ il finit. De cette maniÃ¨re, toutes les lignes Ã  l'intÃ©rieur seront analysÃ©es avant d'Ãªtre exÃ©cutÃ©es. Et si une erreur est dÃ©tectÃ©e, alors rien ne sera exÃ©cutÃ©. C'est un peu moins contraignant que de se retrouver devant une structure Ã  moitiÃ© complÃ¨te qu'il faudra supprimer nous-mÃªme.

```sql
  BEGIN;
  
   -- Les instructions du script

  COMMIT;
```

Le mot clÃ© `BEGIN` va donc permettre de mettre en place la transaction et le mot clÃ© `COMMIT ` d'exÃ©cuter toute les instructions qui sont prÃ©sentes entre le `BEGIN` et `COMMIT`.

### CrÃ©ation des tables

Il nous suffit donc maintenant d'ajouter nos requÃªtes de crÃ©ation de table les une en dessous des autres
Comme n'importe quel script, il sera lu et Ã©xÃ©cutÃ© du haut vers le bas. Ca n'en a pas l'air, mais Ã§a aura son importance plus tard.


```sql
   BEGIN;

   -- ...

   CREATE TABLE "director" (
    	"id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  
    	"firsname" TEXT NOT NULL,
    	"lastname" TEXT NOT NULL
    );
    
    CREATE TABLE "movie" (
      "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  
      "title" TEXT NOT NULL, 
      "year" INTEGER, 
      "excerpt" TEXT,
      "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      "updated_at" TIMESTAMPTZ
    );

   -- ...

   COMMIT;
```

Dans le bout de script, ci dessus, la table `director` sera crÃ©Ã©e avant la table `movie`

### PrÃ©voir la rejouabilitÃ©

Et oui, il n'y a pas que dans les jeux vidÃ©os que la rejouabilitÃ© est importante. Dans nos script SQL aussi. Admettons que notre script Ã©tait bon mais que le client souhaite que notre table des rÃ©alisateurs renseigne Ã©galement leur date de naissance. On va donc ajouter la colonne en question et on voudrait donc rejouer ce script. Toutefois, dans l'Ã©tat actuel, ce script reviendrait en erreur car les tables existent dÃ©jÃ . Donc on va demander une chose supplÃ©mentaire Ã  notre script.

On va tout simplement demander Ã  notre script de supprimer les tables avant de les recrÃ©er. Pour cela, on va utiliser une nouvelle requÃªte SQL, le `DROP`.

```sql
DROP TABLE [nom_table];
``` 
et on va mÃªme lui demander de supprimer la table seulement si elle existe. Et oui, si le script revient en erreur et qu'on souhaite le relancer une fois coriger les `DROP` reviendront en erreur si la table en question n'existe pas.

 ```sql
DROP TABLE IF EXISTS [nom_table] ;
``` 

On va donc supprimer ces tables au dÃ©but du script si elles existent puis on va les recrÃ©er 

```sql


   BEGIN;
   
   DROP TABLE IF EXISTS "movie";
   DROP TABLE IF EXISTS "director";

   -- ...

   CREATE TABLE "director" (
    	"id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  
    	"firsname" TEXT NOT NULL,
    	"lastname" TEXT NOT NULL
    );
    
    CREATE TABLE "movie" (
      "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  
      "title" TEXT NOT NULL, 
      "year" INTEGER, 
      "excerpt" TEXT,
      "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      "updated_at" TIMESTAMPTZ
    );

   -- ...

   COMMIT;

```

Et voilÃ  notre script peut Ãªtre lancÃ© et rejouÃ© autant qu'on le souhaite, il est fin prÃªt ! Hey mais attends ?? On en sais pas encore comment l'exÃ©cuter ce script !

### Execution de la migration

Une fois que le fichier est pret, on peut l'executer avec la commande psql en prÃ©cisant un argument `-f [chemin_vers_fichier]` :

    psql -U movies -f ./migration/movies_structure.sql

qui va executer notre script et gÃ©nÃ©rer la structure de notre base de donnÃ©e avec les tables definies dans le MPD.

> Mais, on ne peux faire que des `CREATE TABLE` ?


## Le seeding

Nous disposons maintenant d'une base de donnÃ©es contenant des tables. C'est un bon dÃ©but, mais il nous manque encore des donnÃ©es pour commencer Ã  interroger nos tables. Il est souvent plus simple de comprendre la logique et les possibilitÃ©s d'une base de donnÃ©es lorsqu'elle est dÃ©jÃ  remplie.

De plus, il peut Ãªtre nÃ©cessaire de prÃ©-remplir notre base de donnÃ©es avec des donnÃ©es qui seront utiles aux utilisateurs. Par exemple, si nous avions crÃ©Ã© une table "genre", nous aurions besoin de la remplir avec plusieurs genres existants pour fournir des exemples.

Le prÃ©-remplissage d'une base de donnÃ©es s'appelle le seeding, et nous allons le mettre en place de maniÃ¨re automatique afin de pouvoir recrÃ©er facilement une base de donnÃ©es contenant le minimum nÃ©cessaire. Ainsi, si quelque chose ne fonctionne pas, il suffira de rÃ©exÃ©cuter le seeding pour revenir Ã  un Ã©tat stable de nos tables.

### CrÃ©ation des fichiers de seeding

Une bonne habitude a prendre est de prefixer nos fichiers de seeding avec un entier qui indique dans quel ordre on doit les executer afin d'eviter d'inserer des donnÃ©es qui dÃ©pendent d'une autre table pas encore remplie.
On va utiliser la syntaxe [INSERT INTO](https://www.postgresql.org/docs/current/sql-insert.html) pour remplir nos tables.

```sql
INSERT INTO genre (id, name) VALUES
(1, 'comedie'),
(2, 'thriller'),
(3, 'horreur'),
(4, 'aventure');
```
Il faut bien penser a ajouter la suppression de toutes les donnÃ©es d'une table avant de la remplir. Sinon, on ne remettra pas la table a zero !

```sql

TRUNCATE TABLE genre;
-- DELETE FROM genre;

INSERT INTO genre (id, name) VALUES
(1, 'comedie'),
(2, 'thriller'),
(3, 'horreur'),
(4, 'aventure');
```

Enfin comme il s'agit d'un script SQL, il faut l'exÃ©cuter dans une transaction.

```sql
BEGIN;

TRUNCATE TABLE genre;

INSERT INTO genre (id, name) VALUES
(1, 'comedie'),
(2, 'thriller'),
(3, 'horreur'),
(4, 'aventure');

COMMIT;

```

Si la table est liÃ© Ã  d'autres table il est important de notÃ© qu'il faut utiliser la notion `CASCADE` avec le `TRUNCATE`. Lorsqu'on utilise `TRUNCATE TABLE nom_table CASCADE;`, cela permet non seulement de vider la table spÃ©cifiÃ©e, mais aussi de supprimer toutes les donnÃ©es des tables qui ont des contraintes de clÃ© Ã©trangÃ¨re avec la table en question. Cette option est utile pour Ã©viter les erreurs de contrainte d'intÃ©gritÃ© lorsqu'on souhaite vider une table qui est rÃ©fÃ©rencÃ©e par d'autres tables.

```sql
BEGIN;

TRUNCATE TABLE genre CASCADE;

INSERT INTO genre (id, name) VALUES
(1, 'comedie'),
(2, 'thriller'),
(3, 'horreur'),
(4, 'aventure');

COMMIT;

```

### Execution du seeding

Pour executer le seeding, il faut executer chacun des fichiers SQL les un a la suite des autres.

```bash
    psql -U movies -f ./seeding/01_directors.sql
```


## Faire un dump de la base de donnÃ©e

Le **dump** d'une base de donnÃ©es consiste Ã  figer le temps. On va prendre une photo Ã  l'instant T de la base de donnÃ©es et gÃ©nÃ©rer un script SQL qui permettrait de regÃ©nÃ©rer la base de donnÃ©es (structure + donnÃ©es) Ã  partir de ce script. L'idÃ©e d'un **dump** est donc principalement de fournir un systÃ¨me de backup. En production on utilisera ces dump afin de revenir Ã  un Ã©tat stable de la base de donnÃ©es. 

On peut aussi se servir d'un dump pour crÃ©er une copie de la base de donnÃ©es afin de pouvoir tester des fonctionnalitÃ© sans impacter la base de donnÃ©es principale.

La commande vous permettant de gÃ©nÃ©rer se fichier est la suivante :

```bash
    pg_dump -U movies > ./dump/dump_movies.sql
```
Ca va generer un nouveau dump qui contiendra toutes les instructions necessaires pour recrÃ©er la base de donnÃ©e



## SynthÃ¨se
C'etait la journÃ©e de prise en main de postgre et de la prÃ©paration pour la base dont on va se servir dans les prochaines journÃ©e
On a vu :
- La syntaxe en ligne de commande pour interagir avec notre BDD via la commande `psql [-U username] [-d database] [-f ./chemin/fichier.sql]`
- la crÃ©ation d'un user `CREATE USER toto WITH PASSWORD 'tata';` et d'une base donnÃ©e `CREATE DATABASE toto WITH OWNER toto;`
- La crÃ©ation de tables `CREATE TABLE name ( champs )` au sein d'une transaction `BEGIN; ... COMMIT;` pour Ã©viter le remplissable partiel en cas d'erreur
- Le seeding, qui nous permet de remplir nos tables (des `INSERT INTO`)
- la commande `pg_dump` qui permet de gÃ©nÃ©rer un backup (dump) de notre base de donnÃ©e.