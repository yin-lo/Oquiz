# Pr√©parer sa base de donn√©es postgresql

Si on remet un peu les choses dans leur contexte, vous savez aujourd'hui interagir avec une base de donn√©es gr√¢ce au langage SQL et vous avez une bonne id√©e de la fa√ßon dont ces bases de donn√©es sont con√ßues. C'est tr√®s cool, mais je peux anticiper votre prochaine question : comment cr√©er la base de donn√©es de nos r√™ves maintenant que nous avons fait une conception aux petits oignons ?

C'est exactement ce que nous allons voir aujourd'hui. Voici quelques questions que nous allons aborder :

   - Comment communiquer avec PostgreSQL pour g√©rer nos bases de donn√©es ? **utilisation de psql**
   - Comment cr√©er une nouvelle base de donn√©es ? **utilisation de CREATE DATABASE**
   - Comment cr√©er un utilisateur sur le serveur PostgreSQL ? **utilisation de CREATE USER**
   - Comment cr√©er une table ? Peut-on automatiser la cr√©ation avec des scripts SQL ? **utilisation de CREATE TABLE**
   - Comment remplir initialement nos tables ? **le seeding**
   - Comment faire une sauvegarde de l'√©tat d'une base de donn√©es ? **le dump**

## La ligne de commande PSQL

Qu'elle soit distante ou locale, pour acc√©der √† une base de donn√©es il faut d'abord s'y connecter. On va utiliser un client en ligne de commande (CLI => command line interface) pour nous y connecter. Ce client s'appelle **psql** et est sp√©cifique aux bases de donn√©es PostgreSQL.

Par d√©faut, si vous lancez la commande psql sans aucun argument, elle essaiera de se connecter au serveur PostgreSQL install√© sur votre machine (localhost) avec l'utilisateur de votre syst√®me d'exploitation.

M√™me si notre objectif est bien de nous connecter √† notre base de donn√©es locale, l'utilisation de notre nom d'utilisateur Windows, Linux ou macOS n'est pas forc√©ment ce que nous voudrons √† l'avenir.

Fort heureusement, comme toutes bonnes commandes de terminal, **psql** vous offre tout un tas d'arguments qui vont vous permettre de sp√©cifier des √©l√©ments de configuration ou de lui indiquer des actions √† r√©aliser. Voici une liste non exhaustive d'arguments que vous pouvez renseigner √† psql :

```
-h [hostname] // sp√©cifie le nom d'h√¥te du serveur PostgreSQL sur lequel vous voulez ex√©cuter psql - par d√©faut, psql utilisera localhost 
-U [username] // sp√©cifie le nom d'utilisateur PostgreSQL que vous voulez utiliser pour vous connecter - par d√©faut le nom d'utilisateur de l'OS
-d [databasename] // sp√©cifie le nom de la base de donn√©es sur laquelle vous voulez travailler - par d√©faut, psql utilisera le nom d'utilisateur
```

Il existe toutefois un `superUser` pour g√©rer votre base de donn√©es, qu'elle soit locale ou non, il s'agit d'un utilisateur cr√©√© sur votre syst√®me d'exploitation au moment de l'installation de PostgreSQL. Cet utilisateur s'appelle `postgres` et il a tous les droits sur votre RDBMS.

Sous Windows, pour vous y connecter vous utiliserez la commande :

```bash
psql -U postgres
```
puis vous entrerez le mot de passe de votre session utilisateur courante.

C'est cet utilisateur qui nous servira dans un premier temps pour cr√©er les bases de donn√©es et les utilisateurs de notre RDBMS

Une fois connect√©, vous aurez acc√®s √† l'√©criture de requ√™te SQL standard, ainsi qu'a certaine commandes de **psql** 

```
\l = liste les base de donn√©es
\du = liste les utilisateurs
\q = quitte psql
\dt = liste les tables de la base de donn√©es sur laquelle on est connect√©e
\d student = d√©crit la table student
...
```

### Cr√©er une base de donn√©e et d'un user avec psql

Une fois connect√© via **psql** avec l'utilisateur `postgres`, on peut cr√©er un utilisateur au sein m√™me de notre RDBMS.

Pourquoi ? Eh bien, en fait, c'est pour des questions de s√©curit√©. En effet, vous retrouverez souvent cette gestion d'utilisateurs dans les environnements en production et pas seulement sur les bases de donn√©es. En production, il est de coutume (peu importe le service, web, base de donn√©es, ftp, mail, ...) de cr√©er des utilisateurs sp√©cifiques pour chaque application mise en production dans un m√™me environnement.

Je m'explique, admettons que vous √™tes l'administrateur d'un serveur qui g√®re la boutique en ligne d'Oclock, O'Shop, ainsi que notre syst√®me d'envoi et de r√©ception de mails. En bon administrateur syst√®me, vous allez tr√®s certainement cr√©er un utilisateur qui va g√©rer l'ex√©cution du site web de la boutique, ainsi qu'un autre qui g√©rera la BDD et encore un pour g√©rer le syst√®me de mail. De m√™me au sein du RDBMS, vous allez donc cr√©er un utilisateur qui va g√©rer l'application O'Shop et un autre qui s'occupera de g√©rer les donn√©es du syst√®me de mail. Bref, l'id√©e est de toujours s√©parer les droits d'une application √† l'autre.

On va donc dans notre DBMS cr√©er un utilisateur sp√©cifique pour chaque base de donn√©es que l'on voudra administrer.

 > Ok, c'est sympa mais concr√®tement, comment on fait ?

Eh bien, une fois connect√© √† votre Postgres avec le superuser `postgres`, on va pouvoir cr√©er un nouvel utilisateur. Voici la syntaxe :

```sql
CREATE USER name [ [ WITH ] option [ ... ] ]
```

√âvidemment, il s'agit de la syntaxe de [la documentation](https://www.postgresql.org/docs/current/sql-createuser.html).

On va essayer de pr√©ciser un peu les choses :

```sql
CREATE USER cinema WITH PASSWORD 'mon_super_mot_de_passe_ultra_secure_parce_que_faut_bien_s√©curier_l_acces_aux_donnees';
```
Dans ce cas pr√©cis, on demande √† Postgres de cr√©er un utilisateur appel√© `cinema` qui aura la possibilit√© de se logger avec le mot de passe mon_super_mot_de_passe_ultra_secure_parce_que_faut_bien_securier_l_acces_aux_donnees.

Voil√†, votre utilisateur est cr√©√©, on va maintenant le lier √† une nouvelle base de donn√©es.

Par ailleurs si vous voulez modifier un √©lement d√©j√† cr√©√©, on peut utiliser la commande `ALTER` soit

```sql
ALTER USER cinema WITH PASSWORD 'mon_nouveau_mot_de_passe';
```

On peut noter qu'on trouvera aussi la commande `DROP` pour supprimer un √©lement.

Comme pour la cr√©ation de l'utilisateur, la syntaxe pour cr√©er une base de donn√©es est d√©crite dans [la documentation](https://www.postgresql.org/docs/current/sql-createdatabase.html) et ressemble √† √ßa :

```sql
CREATE DATABASE name [ WITH ] [ OWNER [=] user_name ]
```

On va demander la cr√©ation de la base et dans le m√™me temps, on va d√©finir notre utilisateur fra√Æchement cr√©√© comme √©tant le propri√©taire de cette derni√®re.

```sql
CREATE DATABASE cinema WITH OWNER cinema;
```

On va maintenant pouvoir quitter psql avec un \q et se connecter avec notre nouvel utilisateur :

```bash
psql -d cinema -U cinema -h localhost

# mais comme psql par d√©faut se connecte √† localhost
psql -d cinema -U cinema

# mais comme psql par d√©faut se connecte √† la bdd qui porte le m√™me nom que l'utilisateur 
psql -U cinema
```

Et voil√†, on a un utilisateur qui a les droits uniquement sur cette base de donn√©es cinema.

### Cr√©er une table en ligne de commande

Parfait, on vient de cr√©er notre premi√®re base en locale et un utilisateur pour l'administrer. On va du coup maintenant pouvoir passer aux choses s√©rieuses et cr√©er nos propres tables. Bien entendu, Postrgres nous founi la syntaxe dans [la documentation](https://www.postgresql.org/docs/current/sql-createtable.html).

Bon, cette fois ci, on va se passer d'afficher la syntaxe ici parce que la doc pourrait √™tre consid√©r√©e comme ... compl√®te üòï

Par contre on peut se faire un premier exemple. Voici un petit MPD pour une table `movie` :

```sql
"movie" (
  "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY, -- Un identifiant unique g√©n√©r√© par le RDBMS
  "title" TEXT NOT NULL, -- il est obligatoire
  "year" INTEGER NOT NULL, -- obligatoire aussi
  "excerpt" TEXT,
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(), -- on veut savoir quand un film a √©t√© ajout√© dans la base et on d√©fini la valeur par d√©faut comme √©tant maintenant       (c'est a dire au moment ou le film sera ajout√©)
  "updated_at TIMESTAMPTZ
)
```

Si on fait la traduction en SQL pour Postgres on aurait simplement √† ajouter l'instruction `CRATE TABLE` devant :

```sql
CREATE TABLE "movie" (
  "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  
  "title" TEXT NOT NULL, 
  "year" INTEGER NOT NULL, 
  "excerpt" TEXT,
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  "updated_at" TIMESTAMPTZ
);
```
Au final, la requ√™te SQL qui permet de cr√©er la table est tr√®s proche du MPD.

```
CREATE TABLE table_name (
   champ1,
   champ2,
   champ3
);
```

Et voila, on a une base de donn√©e la possibilit√© d'y cr√©er des tables.

Bon par contre c'est un peu fastidieux, et je suis pas s√ªr que si je demande √† un adminsys d'√©crire lui aussi les requ√™tes sur le serveur de production il soit super emball√©. Du coup, quel genre d'outils on aime faire pour que les choses aillent plus vite ? Un script !

## Cr√©ation d'un script de deploiement de BDD

L'id√©e, √ßa va √™tre de cr√©er un fichier avec l'extension `.sql` et  qui va contenir une suite d'instructions SQL qui vont permettre de reconstruire toute la structure d'une base de donn√©es. Ce script va contenir principalement des instructions CREATE TABLE qui vont permettre √† n'importe qui d'avoir exactement les m√™mes tables et les m√™mes champs dans une autre base de donn√©es, voire m√™me sur un autre serveur.

### Mise en place de la transaction

> Waouh ! Ok, on va pirater Wall Street ???

Non, pas du tout. En revanche, on va √©changer avec la base de donn√©es et on va lui envoyer beaucoup d'informations en m√™me temps. Du coup, ce serait plut√¥t int√©ressant que la base de donn√©es simule ce qui va se passer avec notre script avant de l'ex√©cuter r√©ellement. Comme √ßa, si il y a des erreurs dans le script, elle pourra tout arr√™ter et nous avertir que le script est faux. Eh bien, c'est justement le principe de la transaction. En fait, on va simplement indiquer √† notre RDBMS √† quel moment notre script d√©marre et o√π il finit. De cette mani√®re, toutes les lignes √† l'int√©rieur seront analys√©es avant d'√™tre ex√©cut√©es. Et si une erreur est d√©tect√©e, alors rien ne sera ex√©cut√©. C'est un peu moins contraignant que de se retrouver devant une structure √† moiti√© compl√®te qu'il faudra supprimer nous-m√™me.

```sql
  BEGIN;
  
   -- Les instructions du script

  COMMIT;
```

Le mot cl√© `BEGIN` va donc permettre de mettre en place la transaction et le mot cl√© `COMMIT ` d'ex√©cuter toute les instructions qui sont pr√©sentes entre le `BEGIN` et `COMMIT`.

### Cr√©ation des tables

Il nous suffit donc maintenant d'ajouter nos requ√™tes de cr√©ation de table les une en dessous des autres
Comme n'importe quel script, il sera lu et √©x√©cut√© du haut vers le bas. Ca n'en a pas l'air, mais √ßa aura son importance plus tard.


```sql
   BEGIN;

   -- ...

   CREATE TABLE "director" (
    	"id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  
    	"firsname" TEXT NOT NULL,
    	"lastname" TEXT NOT NULL
    );
    
    CREATE TABLE "movie" (
      "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  
      "title" TEXT NOT NULL, 
      "year" INTEGER, 
      "excerpt" TEXT,
      "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      "updated_at" TIMESTAMPTZ
    );

   -- ...

   COMMIT;
```

Dans le bout de script, ci dessus, la table `director` sera cr√©√©e avant la table `movie`

### Pr√©voir la rejouabilit√©

Et oui, il n'y a pas que dans les jeux vid√©os que la rejouabilit√© est importante. Dans nos script SQL aussi. Admettons que notre script √©tait bon mais que le client souhaite que notre table des r√©alisateurs renseigne √©galement leur date de naissance. On va donc ajouter la colonne en question et on voudrait donc rejouer ce script. Toutefois, dans l'√©tat actuel, ce script reviendrait en erreur car les tables existent d√©j√†. Donc on va demander une chose suppl√©mentaire √† notre script.

On va tout simplement demander √† notre script de supprimer les tables avant de les recr√©er. Pour cela, on va utiliser une nouvelle requ√™te SQL, le `DROP`.

```sql
DROP TABLE [nom_table];
``` 
et on va m√™me lui demander de supprimer la table seulement si elle existe. Et oui, si le script revient en erreur et qu'on souhaite le relancer une fois coriger les `DROP` reviendront en erreur si la table en question n'existe pas.

 ```sql
DROP TABLE IF EXISTS [nom_table] ;
``` 

On va donc supprimer ces tables au d√©but du script si elles existent puis on va les recr√©er 

```sql


   BEGIN;
   
   DROP TABLE IF EXISTS "movie";
   DROP TABLE IF EXISTS "director";

   -- ...

   CREATE TABLE "director" (
    	"id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  
    	"firsname" TEXT NOT NULL,
    	"lastname" TEXT NOT NULL
    );
    
    CREATE TABLE "movie" (
      "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  
      "title" TEXT NOT NULL, 
      "year" INTEGER, 
      "excerpt" TEXT,
      "created_at" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      "updated_at" TIMESTAMPTZ
    );

   -- ...

   COMMIT;

```

Et voil√† notre script peut √™tre lanc√© et rejou√© autant qu'on le souhaite, il est fin pr√™t ! Hey mais attends ?? On en sais pas encore comment l'ex√©cuter ce script !

### Execution de la migration

Une fois que le fichier est pret, on peut l'executer avec la commande psql en pr√©cisant un argument `-f [chemin_vers_fichier]` :

    psql -U movies -f ./migration/movies_structure.sql

qui va executer notre script et g√©n√©rer la structure de notre base de donn√©e avec les tables definies dans le MPD.

> Mais, on ne peux faire que des `CREATE TABLE` ?


## Le seeding

Nous disposons maintenant d'une base de donn√©es contenant des tables. C'est un bon d√©but, mais il nous manque encore des donn√©es pour commencer √† interroger nos tables. Il est souvent plus simple de comprendre la logique et les possibilit√©s d'une base de donn√©es lorsqu'elle est d√©j√† remplie.

De plus, il peut √™tre n√©cessaire de pr√©-remplir notre base de donn√©es avec des donn√©es qui seront utiles aux utilisateurs. Par exemple, si nous avions cr√©√© une table "genre", nous aurions besoin de la remplir avec plusieurs genres existants pour fournir des exemples.

Le pr√©-remplissage d'une base de donn√©es s'appelle le seeding, et nous allons le mettre en place de mani√®re automatique afin de pouvoir recr√©er facilement une base de donn√©es contenant le minimum n√©cessaire. Ainsi, si quelque chose ne fonctionne pas, il suffira de r√©ex√©cuter le seeding pour revenir √† un √©tat stable de nos tables.

### Cr√©ation des fichiers de seeding

Une bonne habitude a prendre est de prefixer nos fichiers de seeding avec un entier qui indique dans quel ordre on doit les executer afin d'eviter d'inserer des donn√©es qui d√©pendent d'une autre table pas encore remplie.
On va utiliser la syntaxe [INSERT INTO](https://www.postgresql.org/docs/current/sql-insert.html) pour remplir nos tables.

```sql
INSERT INTO genre (id, name) VALUES
(1, 'comedie'),
(2, 'thriller'),
(3, 'horreur'),
(4, 'aventure');
```
Il faut bien penser a ajouter la suppression de toutes les donn√©es d'une table avant de la remplir. Sinon, on ne remettra pas la table a zero !

```sql

TRUNCATE TABLE genre;
-- DELETE FROM genre;

INSERT INTO genre (id, name) VALUES
(1, 'comedie'),
(2, 'thriller'),
(3, 'horreur'),
(4, 'aventure');
```

Enfin comme il s'agit d'un script SQL, il faut l'ex√©cuter dans une transaction.

```sql
BEGIN;

TRUNCATE TABLE genre;

INSERT INTO genre (id, name) VALUES
(1, 'comedie'),
(2, 'thriller'),
(3, 'horreur'),
(4, 'aventure');

COMMIT;

```

Si la table est li√© √† d'autres table il est important de not√© qu'il faut utiliser la notion `CASCADE` avec le `TRUNCATE`. Lorsqu'on utilise `TRUNCATE TABLE nom_table CASCADE;`, cela permet non seulement de vider la table sp√©cifi√©e, mais aussi de supprimer toutes les donn√©es des tables qui ont des contraintes de cl√© √©trang√®re avec la table en question. Cette option est utile pour √©viter les erreurs de contrainte d'int√©grit√© lorsqu'on souhaite vider une table qui est r√©f√©renc√©e par d'autres tables.

```sql
BEGIN;

TRUNCATE TABLE genre CASCADE;

INSERT INTO genre (id, name) VALUES
(1, 'comedie'),
(2, 'thriller'),
(3, 'horreur'),
(4, 'aventure');

COMMIT;

```

### Execution du seeding

Pour executer le seeding, il faut executer chacun des fichiers SQL les un a la suite des autres.

```bash
    psql -U movies -f ./seeding/01_directors.sql
```


## Faire un dump de la base de donn√©e

Le **dump** d'une base de donn√©es consiste √† figer le temps. On va prendre une photo √† l'instant T de la base de donn√©es et g√©n√©rer un script SQL qui permettrait de reg√©n√©rer la base de donn√©es (structure + donn√©es) √† partir de ce script. L'id√©e d'un **dump** est donc principalement de fournir un syst√®me de backup. En production on utilisera ces dump afin de revenir √† un √©tat stable de la base de donn√©es. 

On peut aussi se servir d'un dump pour cr√©er une copie de la base de donn√©es afin de pouvoir tester des fonctionnalit√© sans impacter la base de donn√©es principale.

La commande vous permettant de g√©n√©rer se fichier est la suivante :

```bash
    pg_dump -U movies > ./dump/dump_movies.sql
```
Ca va generer un nouveau dump qui contiendra toutes les instructions necessaires pour recr√©er la base de donn√©e



## Synth√®se
C'etait la journ√©e de prise en main de postgre et de la pr√©paration pour la base dont on va se servir dans les prochaines journ√©e
On a vu :
- La syntaxe en ligne de commande pour interagir avec notre BDD via la commande `psql [-U username] [-d database] [-f ./chemin/fichier.sql]`
- la cr√©ation d'un user `CREATE USER toto WITH PASSWORD 'tata';` et d'une base donn√©e `CREATE DATABASE toto WITH OWNER toto;`
- La cr√©ation de tables `CREATE TABLE name ( champs )` au sein d'une transaction `BEGIN; ... COMMIT;` pour √©viter le remplissable partiel en cas d'erreur
- Le seeding, qui nous permet de remplir nos tables (des `INSERT INTO`)
- la commande `pg_dump` qui permet de g√©n√©rer un backup (dump) de notre base de donn√©e.