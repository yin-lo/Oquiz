# Passer de la conception à l'implémentation

Nous avons vu le MCD, le _modèle conceptuel des données_. Il s'agit d'un schéma pour lister les entités d'un projet, leurs attributs et leurs associations. Comme son nom l'indique, il est purement conceptuel et pourrait être traduit vers n'importe quel DBMS.  
On va pouvoir ensuite partir de ce MCD pour en déduire l'implémentation réelle de notre base de données sur le DBMS de notre choix. On parle d'implémentation _physique_. Notre implémentation va viser le DBMS relationnelle PostgreSQL puisque c'est celui que nous allons utiliser durant ce module.

## Passer du MCD au MLD

Nous avions cité les étapes suivantes pour arriver à l'implémentation physique de notre base de données.

1. MCD
2. MLD
3. MPD

L'étape 1 étant réalisée on va passer à l'étape 2, à savoir le MLD.

<details>
  <summary>Revoir le MCD</summary>

![MCD](/img/mcd.png)

</details>

MLD signifie _Modèle Logique des Données_. Son rôle est de traduire les associations vers quelque chose d'implémentable dans notre RDBMS.

Le MLD découle du MCD. On applique les règles suivantes :

1. Chaque entité du MCD devient une table
2. Chaque attribut d'une entité devient une colonne de cette table qu'on écrit entre parenthèses à côté
3. L'attribut discriminant devient un identifiant qu'on souligne
4. On traduit les associations selon la méthode qui suit :
   1. Pour une association One To One on crée une clé étrangère sur une des 2 entités de l'association au choix
   2. Pour une association One To Many on crée une clé étrangère sur l'entité du côté 1. Une clé étrangère est une colonne qui fait référence à l'indentifiant de la table côté N
   3. Pour une association Many To Many on crée une table de liaison (souvent nommé firstentity_has_secondentity). Cette table de liaison contient 2 colonnes : une clé étrangère vers la première entité et une clé étrangère vers la seconde entité et éventuellement une colonne d'identifiant.
5. On met un dièse # devant les clés étrangères pour les reconnaître tout de suite

Cela donnerait le MLD suivant pour le MCD d'exemple :

> post (<span style="text-decoration: underline">id</span>, title, content, #user_id)  
> post_has_tag (<span style="text-decoration: underline">id</span>, #post_id, #tag_id)  
> user (<span style="text-decoration: underline">id</span>, email, password, firstname, lastname)  
> tag (<span style="text-decoration: underline">id</span>, label)

Et voilà ! On note la clé étrangère dans la table post faisant référence à l'id de l'utilisateur qu'il l'a écrit. Ainsi un post est bien écrit par un et un seul utilisateur.  
On note également la table de liaison post_has_tag pour associer potentiellement plusieurs posts au même tag et plusieurs tags au même post.

A ce stade pour bien se représenter les choses on peut imaginer à quoi ressembleront les lignes de nos tables pour voir qu'elles traduisent bien nos associations.

Exemple

**user**

|id|email|password|firstname|lastname|
|---|---|---|---|---|
|1|toto@tata.com|_hashdupassword_|Toto|Dupont|
|2|john@tata.com|_hashdupassword_|John|Doe|

**tag**

|id|label|
|---|---|
|1|CSS|
|2|HTML|
|3|Javascript|

**post**

|id|title|content|user_id|
|---|---|---|---|
|1|On vous dit tout sur la balise script|Lorem ipsum|1|
|2|On vous dit tout sur la balise title|Lorem ipsum|2|
|3|On vout dit tout sur la proriété font-size|Lorem ipsum|1|

- Le post 1 est écrit par l'utilisateur 1 donc toto
- Le post 2 est écrit par l'utilisateur 2 donc john
- Le post 3 est écrit par l'utilisateur 1 donc toto

La requête SQL pour sélectionner les titres des articles et le nom de leur auteur se ferait donc avec `JOIN`

Exemple

```sql
SELECT "user"."firstname", "post"."title"
FROM "post"
JOIN "user"
  ON "post"."user_id" = "user"."id";
```

**post_has_tag**

|id|post_id|tag_id|
|---|---|---|
|1|1|2|
|2|1|3|
|3|2|2|
|4|3|1|

- Le post 1 (balise script) a le tag 2 donc HTML
- Le post 1 (balise script) a le tag 3 donc javascript
- Le post 2 (balise title) a le tag 2 donc HTML
- Le post 3 (propriété font-size) a le tag 1 donc CSS

La requête SQL pour sélectionner le titre des articles et le label des tags associés se fera avec 2 `JOIN`

```sql
SELECT "tag"."label", "post"."title"
FROM "post_has_tag"
JOIN "post"
  ON "post"."id" = "post_has_tag"."post_id"
JOIN "tag"
  ON "tag"."id" = "post_has_tag"."tag_id";
```

## Passer du MLD au MPD

Nos tables sont presque prêtes à être créées. Toutefois on va pouvoir apporter davantage de précisions.

C'est ce qu'on fait au niveau du MPD, le _Modèle Physique des Données_, qui correspondra exactement à notre script de création de base de données par la suite. Il est donc adapté à un DBMS en particulier. Il découle finalement du MLD

On y ajoute

- Le type de chaque colonne
- Les contraintes éventuelles de chaque colonne

Le type c'est le type des valeurs d'une colonne. Par exemple des nombres (`INTEGER`), du texte `TEXT` ou des dates (`TIMESTAMPTZ`). On a [tous les types possibles dans la documentation](https://www.postgresql.org/docs/current/datatype.html) de notre DBMS, ici PostgreSQL.

Les contraintes permettent de préciser ce qu'on attend dans chaque colonnes. Ainsi notre DBMS renverra une erreur si on ne respecte pas ces contraintes.  
Par exemple

- une colonne marqué `NOT NULL` renverra une erreur si on essaye d'insérer une ligne sans cette valeur obligatoire.

On peut citer également les contraintes

- `UNIQUE` pour garantir l'unicité des valeurs, 
- `PRMARY KEY` qui est la combinaison de `UNIQUE` et `NOT NULL` qu'on utilise sur les identifiants ou la contrainte 
- `REFERENCES` pour indiquer que les valeurs d'une colonne doivent exister dans une autre table, pratique pour nos clés étrangères.

Encore une fois la [documentation des contraintes](https://www.postgresql.org/docs/current/ddl-constraints.html) sera à consulter pour voir toutes les possibilités.

Ainsi notre MPD donnera pour l'exemple

```sql
"user" (
  "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY, 
  -- chaque ligne devra avoir un id de type nombre entier unique. 
  -- "GENERATED ALWAYS AS IDENTITY" est une commande SQL pour préciser qu'on ne mettra pas les id manuellement
  -- c'est notre DBMS qui va les générer tout seul, trop pratique
  "email" TEXT UNIQUE NOT NULL, -- 2 utilisateurs ne peuvent pas avoir le même email, il est obligatoire
  "password" TEXT NOT NULL, -- le mot de passe est obligatoire
  "firstname" TEXT, -- le prénom et le nom ne sont pas obligatoires
  "lastname" TEXT,
)

"tag" (
  "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY, 
  "label" TEXT NOT NULL
)

"post" (
  "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY, 
  "title" TEXT NOT NULL,
  "content" TEXT DEFAULT "Prochainement...", -- via DEFAULT on peut attribuer une valeur par défaut dans le cas où on ajoute une ligne sans cette colonne
  "user_id" INTEGER REFERENCES "user"("id") NOT NULL -- la contrainte de référence permet de vérifier que l'utilisateur associé existe
)

"post_has_tag" (
  "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY, 
  "post_id" INTEGER REFERENCES "post"("id"),
  "tag_id" INTEGER REFERENCES "tag"("id"),
)

```

Nos tables sont parfaitement définies. Il ne nous restera plus qu'à voir comment executer la création dans notre DBMS lors de la prochaine journée.

Ces étapes peuvent être réalisées à la création d'un projet, on n'y sera pas forcément confronté directement en tant que développeur junior. On a tout de même besoin de s'y intéresser pour comprendre comment s'organise une base de données, ça nous permettra de bien les utiliser par la suite ne serait-ce que pour mieux comprendre les `JOIN` par exemple ;)

---

## Synthèse

- Le MLD (modèle logique des données) découle du MCD et traduit en plus les associations selon quelques règles à respecter, principalement :
  - L'ajout d'une colonne clé étrangère pour du One To Many
  - L'ajout d'une table de liaison avec 2 clés étrangères pour du Many To Many
- Le MPD (modèle physique des données) découle du MLD et contient en plus les types et les contraintes propres à notre DBMS dans le but de décrire des tables prêtes à être créées dans notre DBMS.
- Avec postgreSQL on disposera 
  - de différents [types](https://www.postgresql.org/docs/current/datatype.html) comme `INTEGER` ou `TEXT`
  - de [contraintes](https://www.postgresql.org/docs/current/ddl-constraints.html) comme `NOT NULL`, `UNIQUE` ou `REFERENCES`